// Code generated by MockGen. DO NOT EDIT.
// Source: internal/sysaccess/authorized_keys_file_updater.go
//
// Generated by this command:
//
//	mockgen -source=internal/sysaccess/authorized_keys_file_updater.go -package=sysaccess -destination=internal/sysaccess/authorized_keys_file_updater_mocks.go
//

// Package sysaccess is a generated GoMock package.
package sysaccess

import (
	reflect "reflect"

	gomock "go.uber.org/mock/gomock"
)

// MockauthorizedKeysFileUpdater is a mock of authorizedKeysFileUpdater interface.
type MockauthorizedKeysFileUpdater struct {
	ctrl     *gomock.Controller
	recorder *MockauthorizedKeysFileUpdaterMockRecorder
	isgomock struct{}
}

// MockauthorizedKeysFileUpdaterMockRecorder is the mock recorder for MockauthorizedKeysFileUpdater.
type MockauthorizedKeysFileUpdaterMockRecorder struct {
	mock *MockauthorizedKeysFileUpdater
}

// NewMockauthorizedKeysFileUpdater creates a new mock instance.
func NewMockauthorizedKeysFileUpdater(ctrl *gomock.Controller) *MockauthorizedKeysFileUpdater {
	mock := &MockauthorizedKeysFileUpdater{ctrl: ctrl}
	mock.recorder = &MockauthorizedKeysFileUpdaterMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockauthorizedKeysFileUpdater) EXPECT() *MockauthorizedKeysFileUpdaterMockRecorder {
	return m.recorder
}

// updateAuthorizedKeysFile mocks base method.
func (m *MockauthorizedKeysFileUpdater) updateAuthorizedKeysFile(osUsername string, managedKeys []*SSHKey) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "updateAuthorizedKeysFile", osUsername, managedKeys)
	ret0, _ := ret[0].(error)
	return ret0
}

// updateAuthorizedKeysFile indicates an expected call of updateAuthorizedKeysFile.
func (mr *MockauthorizedKeysFileUpdaterMockRecorder) updateAuthorizedKeysFile(osUsername, managedKeys any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "updateAuthorizedKeysFile", reflect.TypeOf((*MockauthorizedKeysFileUpdater)(nil).updateAuthorizedKeysFile), osUsername, managedKeys)
}
